# 模拟数据生成机制设计

## 1. 系统架构

```
┌─────────────────────────────────────────────────────────────┐
│                     后端服务架构                                │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  ┌──────────────────┐         ┌──────────────────┐        │
│  │  FastAPI 主服务   │         │  数据生成守护进程  │        │
│  │  (API 服务)      │         │  (独立进程)       │        │
│  └──────────────────┘         └──────────────────┘        │
│         │                              │                   │
│         │ 读取                          │ 写入              │
│         ↓                              ↓                   │
│  ┌──────────────────────────────────────────────┐         │
│  │           数据库 (SQLite/PostgreSQL)          │         │
│  │                                              │         │
│  │  ┌─────────────────────────────────────┐    │         │
│  │  │  market_klines (K线数据表)          │    │         │
│  │  │  - symbol: 股票代码                 │    │         │
│  │  │  - interval: 周期 (1m/5m/15m...)   │    │         │
│  │  │  - time: 时间戳                     │    │         │
│  │  │  - open/high/low/close/volume      │    │         │
│  │  └─────────────────────────────────────┘    │         │
│  │                                              │         │
│  │  ┌─────────────────────────────────────┐    │         │
│  │  │  market_status (市场状态表)         │    │         │
│  │  │  - is_trading: 是否交易时段          │    │         │
│  │  │  - last_update: 最后更新时间         │    │         │
│  │  └─────────────────────────────────────┘    │         │
│  └──────────────────────────────────────────────┘         │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

## 2. 交易时段规则

### A 股交易时间（北京时间）

| 时段 | 开始时间 | 结束时间 | 说明 |
|------|---------|---------|------|
| 集合竞价 | 09:15 | 09:25 | 不生成数据 |
| 早盘 | 09:30 | 11:30 | 生成数据 |
| 午休 | 11:30 | 13:00 | 不生成数据 |
| 午盘 | 13:00 | 15:00 | 生成数据 |
| 收盘 | 15:00 | 次日 09:30 | 不生成数据 |

### 周末和节假日

- 周六、周日：不生成数据
- 法定节假日：不生成数据（可配置）

## 3. 数据生成算法

### 3.1 价格生成算法（布朗运动 + 趋势）

```python
def generate_next_price(
    current_price: float,
    volatility: float = 0.02,    # 波动率
    trend: float = 0.0,           # 趋势因子 (-1 到 1)
    dt: float = 1/240             # 时间步长（1分钟 = 1/240 交易日）
) -> dict:
    """
    生成下一分钟的 OHLC 数据

    使用几何布朗运动 (Geometric Brownian Motion):
    dS = μ * S * dt + σ * S * dW

    其中：
    - S: 当前价格
    - μ: 漂移率（趋势）
    - σ: 波动率
    - dW: 维纳过程（正态分布随机数）
    """
    import numpy as np

    # 1. 计算价格变化
    drift = trend * dt  # 趋势项
    shock = volatility * np.sqrt(dt) * np.random.normal(0, 1)  # 随机项
    price_change = current_price * (drift + shock)

    # 2. 计算收盘价
    close = current_price + price_change

    # 3. 生成 OHLC
    # 在 [close - range, close + range] 范围内生成 high/low
    intraday_volatility = abs(price_change) * 1.5

    high = close + abs(np.random.normal(0, intraday_volatility * 0.5))
    low = close - abs(np.random.normal(0, intraday_volatility * 0.5))
    open_price = current_price

    # 确保 OHLC 合理性
    high = max(high, open_price, close)
    low = min(low, open_price, close)

    # 4. 生成成交量（基于价格波动）
    base_volume = 1_000_000  # 基础成交量
    volume_factor = abs(price_change / current_price) * 10 + 1
    volume = int(base_volume * volume_factor * np.random.uniform(0.5, 1.5))

    return {
        'open': round(open_price, 2),
        'high': round(high, 2),
        'low': round(low, 2),
        'close': round(close, 2),
        'volume': volume
    }
```

### 3.2 趋势模拟（马尔可夫状态机）

模拟市场的不同状态：

```python
class MarketState:
    """市场状态"""
    BULL = "上涨"      # 牛市，trend = 0.3
    BEAR = "下跌"      # 熊市，trend = -0.3
    SIDEWAYS = "盘整"  # 震荡，trend = 0.0
    VOLATILE = "波动"  # 高波动，volatility * 2

# 状态转移概率矩阵
TRANSITION_PROBABILITY = {
    MarketState.BULL: {
        MarketState.BULL: 0.7,      # 70% 继续上涨
        MarketState.SIDEWAYS: 0.2,  # 20% 转为盘整
        MarketState.BEAR: 0.1,      # 10% 转为下跌
    },
    MarketState.BEAR: {
        MarketState.BEAR: 0.7,      # 70% 继续下跌
        MarketState.SIDEWAYS: 0.2,  # 20% 转为盘整
        MarketState.BULL: 0.1,      # 10% 转为上涨
    },
    MarketState.SIDEWAYS: {
        MarketState.SIDEWAYS: 0.6,  # 60% 继续盘整
        MarketState.BULL: 0.2,      # 20% 转为上涨
        MarketState.BEAR: 0.2,      # 20% 转为下跌
    }
}
```

### 3.3 多股票相关性

为了模拟真实市场，不同股票之间应该有相关性：

```python
def generate_correlated_returns(
    num_stocks: int,
    correlation: float = 0.3  # 相关系数
) -> np.ndarray:
    """
    生成具有相关性的股票收益率

    使用 Cholesky 分解生成相关的随机数
    """
    # 1. 构造相关矩阵
    corr_matrix = np.full((num_stocks, num_stocks), correlation)
    np.fill_diagonal(corr_matrix, 1.0)

    # 2. Cholesky 分解
    L = np.linalg.cholesky(corr_matrix)

    # 3. 生成独立的随机数
    independent_random = np.random.normal(0, 1, num_stocks)

    # 4. 生成相关的随机数
    correlated_random = L @ independent_random

    return correlated_random
```

## 4. 数据库设计

### 4.1 K线数据表

```sql
CREATE TABLE market_klines (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    symbol VARCHAR(20) NOT NULL,           -- 股票代码
    interval VARCHAR(10) NOT NULL,          -- 周期 (1m, 5m, 15m, 30m, 1h, 4h, 1d)
    time INTEGER NOT NULL,                  -- 时间戳（秒）
    open DECIMAL(10, 2) NOT NULL,           -- 开盘价
    high DECIMAL(10, 2) NOT NULL,           -- 最高价
    low DECIMAL(10, 2) NOT NULL,            -- 最低价
    close DECIMAL(10, 2) NOT NULL,          -- 收盘价
    volume BIGINT NOT NULL,                 -- 成交量
    turnover DECIMAL(20, 2),                -- 成交额
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,

    -- 联合唯一索引，确保每个 (symbol, interval, time) 唯一
    UNIQUE(symbol, interval, time)
);

-- 索引优化查询性能
CREATE INDEX idx_symbol_interval ON market_klines(symbol, interval);
CREATE INDEX idx_time ON market_klines(time);
```

### 4.2 股票状态表

```sql
CREATE TABLE stock_state (
    symbol VARCHAR(20) PRIMARY KEY,
    current_price DECIMAL(10, 2) NOT NULL,  -- 当前价格
    last_close DECIMAL(10, 2) NOT NULL,     -- 昨收价
    market_state VARCHAR(20),                -- 市场状态
    trend DECIMAL(5, 4),                     -- 当前趋势
    volatility DECIMAL(5, 4),                -- 当前波动率
    last_update INTEGER NOT NULL             -- 最后更新时间
);
```

### 4.3 市场状态表

```sql
CREATE TABLE market_status (
    id INTEGER PRIMARY KEY DEFAULT 1,
    is_trading BOOLEAN NOT NULL DEFAULT 0,   -- 是否交易时段
    current_time INTEGER NOT NULL,           -- 当前市场时间（用于测试）
    speed_multiplier INTEGER DEFAULT 1,      -- 时间加速倍数（测试用）
    last_update TIMESTAMP DEFAULT CURRENT_TIMESTAMP,

    CHECK (id = 1)  -- 确保只有一行记录
);
```

## 5. 数据生成守护进程

### 5.1 守护进程架构

```python
# backend/data_generator/daemon.py

import time
import schedule
from datetime import datetime, time as dt_time
from typing import List
import logging

class MarketDataGenerator:
    """市场数据生成器守护进程"""

    def __init__(self, db_connection):
        self.db = db_connection
        self.stocks = self.load_stocks()  # 加载股票列表
        self.stock_states = {}            # 股票状态

    def is_trading_time(self) -> bool:
        """判断是否交易时段"""
        now = datetime.now()

        # 周末不交易
        if now.weekday() >= 5:  # 5=周六, 6=周日
            return False

        current_time = now.time()

        # 早盘：09:30 - 11:30
        morning_start = dt_time(9, 30)
        morning_end = dt_time(11, 30)

        # 午盘：13:00 - 15:00
        afternoon_start = dt_time(13, 0)
        afternoon_end = dt_time(15, 0)

        is_morning = morning_start <= current_time <= morning_end
        is_afternoon = afternoon_start <= current_time <= afternoon_end

        return is_morning or is_afternoon

    def generate_minute_data(self):
        """生成 1 分钟数据（每分钟执行一次）"""
        if not self.is_trading_time():
            logging.info("非交易时段，跳过数据生成")
            return

        logging.info(f"生成 {len(self.stocks)} 只股票的 1 分钟数据")

        timestamp = int(time.time())

        for stock in self.stocks:
            symbol = stock['symbol']

            # 获取或初始化股票状态
            if symbol not in self.stock_states:
                self.stock_states[symbol] = self.initialize_stock_state(symbol)

            state = self.stock_states[symbol]

            # 生成下一分钟数据
            kline = generate_next_price(
                current_price=state['current_price'],
                volatility=state['volatility'],
                trend=state['trend']
            )

            # 保存到数据库
            self.save_kline(symbol, '1m', timestamp, kline)

            # 更新股票状态
            state['current_price'] = kline['close']

            # 状态转移（每 10 分钟可能转换状态）
            if timestamp % 600 == 0:
                state['market_state'] = self.transition_state(state['market_state'])
                state['trend'] = self.get_trend_for_state(state['market_state'])

        # 更新市场状态
        self.update_market_status(timestamp, is_trading=True)

    def save_kline(self, symbol: str, interval: str, timestamp: int, kline: dict):
        """保存 K 线数据到数据库"""
        self.db.execute("""
            INSERT OR REPLACE INTO market_klines
            (symbol, interval, time, open, high, low, close, volume, turnover)
            VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
        """, (
            symbol, interval, timestamp,
            kline['open'], kline['high'], kline['low'], kline['close'],
            kline['volume'], kline['volume'] * kline['close']
        ))
        self.db.commit()

    def run(self):
        """启动守护进程"""
        logging.info("市场数据生成器启动")

        # 每分钟执行一次
        schedule.every(1).minutes.do(self.generate_minute_data)

        # 每小时聚合数据（生成 5m, 15m, 30m, 1h 等周期）
        schedule.every(5).minutes.do(lambda: self.aggregate_klines('5m'))
        schedule.every(15).minutes.do(lambda: self.aggregate_klines('15m'))
        schedule.every(30).minutes.do(lambda: self.aggregate_klines('30m'))
        schedule.every(60).minutes.do(lambda: self.aggregate_klines('60m'))

        # 主循环
        while True:
            schedule.run_pending()
            time.sleep(30)  # 每 30 秒检查一次
```

### 5.2 数据聚合

```python
def aggregate_klines(self, target_interval: str):
    """
    从 1 分钟数据聚合生成其他周期数据

    例如：5 分钟 K 线 = 5 根 1 分钟 K 线聚合
    - open = 第一根的 open
    - high = 5 根中的最高 high
    - low = 5 根中的最低 low
    - close = 最后一根的 close
    - volume = 5 根 volume 求和
    """
    interval_minutes = {
        '5m': 5,
        '15m': 15,
        '30m': 30,
        '60m': 60,
        '120m': 120,
    }

    minutes = interval_minutes.get(target_interval)
    if not minutes:
        return

    for stock in self.stocks:
        symbol = stock['symbol']

        # 获取最近 N 分钟的 1m 数据
        result = self.db.execute("""
            SELECT time, open, high, low, close, volume
            FROM market_klines
            WHERE symbol = ? AND interval = '1m'
            ORDER BY time DESC
            LIMIT ?
        """, (symbol, minutes)).fetchall()

        if len(result) < minutes:
            continue

        # 聚合数据
        aggregated_time = (result[0]['time'] // (minutes * 60)) * (minutes * 60)
        aggregated = {
            'open': result[-1]['open'],
            'high': max(r['high'] for r in result),
            'low': min(r['low'] for r in result),
            'close': result[0]['close'],
            'volume': sum(r['volume'] for r in result)
        }

        # 保存聚合后的数据
        self.save_kline(symbol, target_interval, aggregated_time, aggregated)
```

## 6. 数据初始化

### 6.1 初始化历史数据

```python
def initialize_historical_data(
    symbol: str,
    start_date: datetime,
    end_date: datetime,
    initial_price: float = 10.0
):
    """
    初始化历史数据

    从 start_date 到 end_date 生成历史 K 线数据
    用于新股票的数据回填
    """
    current_date = start_date
    current_price = initial_price

    while current_date <= end_date:
        # 跳过周末
        if current_date.weekday() >= 5:
            current_date += timedelta(days=1)
            continue

        # 早盘：09:30 - 11:30 (120 分钟)
        for minute in range(120):
            timestamp = int((current_date + timedelta(
                hours=9, minutes=30 + minute
            )).timestamp())

            kline = generate_next_price(current_price)
            save_kline(symbol, '1m', timestamp, kline)
            current_price = kline['close']

        # 午盘：13:00 - 15:00 (120 分钟)
        for minute in range(120):
            timestamp = int((current_date + timedelta(
                hours=13, minutes=minute
            )).timestamp())

            kline = generate_next_price(current_price)
            save_kline(symbol, '1m', timestamp, kline)
            current_price = kline['close']

        current_date += timedelta(days=1)
```

## 7. 启动脚本

### 7.1 守护进程启动脚本

```bash
# backend/scripts/start_data_generator.sh

#!/bin/bash

# 激活虚拟环境
cd "$(dirname "$0")/.."
source venv/bin/activate  # Linux/Mac
# 或
# venv\Scripts\activate  # Windows

# 启动数据生成器
python -m data_generator.daemon &

# 保存 PID
echo $! > data_generator.pid

echo "数据生成器已启动，PID: $(cat data_generator.pid)"
```

### 7.2 Windows 服务方式

```python
# backend/data_generator/service.py

import win32serviceutil
import win32service
import win32event
import servicemanager

class MarketDataService(win32serviceutil.ServiceFramework):
    _svc_name_ = "HappyStockDataGenerator"
    _svc_display_name_ = "HappyStock Market Data Generator"
    _svc_description_ = "生成模拟股票行情数据"

    def __init__(self, args):
        win32serviceutil.ServiceFramework.__init__(self, args)
        self.stop_event = win32event.CreateEvent(None, 0, 0, None)
        self.generator = None

    def SvcStop(self):
        self.ReportServiceStatus(win32service.SERVICE_STOP_PENDING)
        win32event.SetEvent(self.stop_event)

    def SvcDoRun(self):
        self.generator = MarketDataGenerator(get_db_connection())
        self.generator.run()

if __name__ == '__main__':
    win32serviceutil.HandleCommandLine(MarketDataService)
```

## 8. 配置文件

```yaml
# backend/config/data_generator.yaml

market:
  timezone: "Asia/Shanghai"

  trading_hours:
    morning:
      start: "09:30"
      end: "11:30"
    afternoon:
      start: "13:00"
      end: "15:00"

  holidays:  # 法定节假日（不生成数据）
    - "2025-01-01"  # 元旦
    - "2025-01-28"  # 春节
    # ...

stocks:
  # 初始股票列表
  - symbol: "SH600000"
    name: "浦发银行"
    initial_price: 10.0
    volatility: 0.02

  - symbol: "SH600036"
    name: "招商银行"
    initial_price: 45.0
    volatility: 0.025

generation:
  base_volatility: 0.02       # 基础波动率
  trend_change_interval: 600  # 趋势转换间隔（秒）
  correlation: 0.3            # 股票间相关性

database:
  path: "data/market.db"
  backup_interval: 3600       # 备份间隔（秒）
```

## 9. 测试和验证

### 9.1 数据质量检查

```python
def validate_kline_data():
    """验证 K 线数据的合理性"""

    checks = [
        # 1. OHLC 合理性：low <= open,close <= high
        "SELECT COUNT(*) FROM market_klines WHERE low > open OR low > close OR high < open OR high < close",

        # 2. 成交量非负
        "SELECT COUNT(*) FROM market_klines WHERE volume < 0",

        # 3. 价格非负
        "SELECT COUNT(*) FROM market_klines WHERE open < 0 OR high < 0 OR low < 0 OR close < 0",

        # 4. 时间连续性（1 分钟数据）
        """
        SELECT symbol, COUNT(*) as gaps
        FROM (
            SELECT symbol, time,
                   LAG(time) OVER (PARTITION BY symbol ORDER BY time) as prev_time
            FROM market_klines
            WHERE interval = '1m'
        )
        WHERE time - prev_time > 60
        GROUP BY symbol
        """
    ]

    for check in checks:
        result = db.execute(check).fetchone()
        if result[0] > 0:
            logging.warning(f"数据质量问题：{check}")
```

## 10. 优化和扩展

### 10.1 性能优化

1. **批量插入**：每分钟收集所有股票数据，一次性批量插入
2. **异步写入**：使用消息队列（Redis）缓冲数据
3. **分区表**：按日期分区存储历史数据

### 10.2 功能扩展

1. **盘口数据**：生成买卖五档数据
2. **分时数据**：生成分时成交明细
3. **资金流向**：模拟主力资金流入流出
4. **财务数据**：生成基本面数据

---

*设计文档版本：v1.0*
*最后更新：2025-10-27*
